package com.chocolabs.airlocker.utils;

import java.io.UnsupportedEncodingException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Properties;

import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.activation.FileDataSource;
import javax.mail.BodyPart;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;

import com.chocolabs.airlocker.Act_GestureTest;
import com.chocolabs.airlocker.Act_NumTest;
import com.chocolabs.airlocker.AppLog;
import com.chocolabs.airlocker.AppLogDao;
import com.chocolabs.airlocker.App_AirLocker;
import com.chocolabs.airlocker.Bcr_BroadcastReceiver;
import com.chocolabs.airlocker.DaoMaster;
import com.chocolabs.airlocker.DaoSession;
import com.chocolabs.airlocker.R;
import com.chocolabs.airlocker.DaoMaster.DevOpenHelper;
import com.google.android.gms.analytics.HitBuilders;
import com.google.android.gms.analytics.Tracker;

import de.greenrobot.dao.query.QueryBuilder;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.database.sqlite.SQLiteDatabase;
import android.os.AsyncTask;
import android.preference.PreferenceManager;
import android.util.Log;

/* 
 *  
 * Provide interface to default preference 
 * 
 */
public class Setting implements OnSharedPreferenceChangeListener {
  
	public static final String EXTRA_PACKAGE_NAME = "com.chocolabs.applocker.extra.package.name";
	public static final String BlockedPackageName = "locked package name";
	public static final String BlockedActivityName = "locked activity name";
	public static final String ACTION_APPLICATION_PASSED = "com.chocolabs.airlocker.applicationpassedtest";
	public static  Class<?> DEFAULT_LOCK_SCREEN_ACTIVITY_CLASS = Act_GestureTest.class;
	public static final int ERROR_SHRESHOLD = 3;
	public static final String SERVICE_MAIL_ACCOUNT = "airlocker@chocolabs.com";
	public static final String SERVICE_MAIL_PASSWORD = "Choco321";
	public static final String ACTION_WEEKLYREPORT_SEND = "ACTION_WEEKLYREPORT_SEND";
	
	
	// TODO: Setup below to avoid hard coded package/activity name
//	public static final String DEFAULT_LOCK_SCREEN_ACTIVITY = Act_GestureTest.class.getName();//  Act_GestureTest.class.getName();
//	public static final String DEFAULT_LOCK_SCREEN_ACTIVITY_SIMPLE = Act_GestureTest.class.getSimpleName();//  Act_GestureTest.class.getName();

	public static Setting getInstance(Context context) {
		return mInstance == null ? (mInstance = new Setting(context))
				: mInstance;
	}
	
	public boolean isWeeklyReport() {
		return mWeeklyReport;
	}

	public boolean isAutoStart() {
		return mAutoStart;
	}

	public boolean isServiceEnabled() {
		return mServiceEnabled;
	}

	public boolean isFirstUse() {
		return mFirstUse;
	}

	public void setFirstUse(boolean first) {
		mFirstUse = first;
		mPref.edit().putBoolean(PREF_FIRST_USE, first).commit();
		this.reloadPreferences();
	}
	
	public String[] getApplicationList() {
		return mApplicationList;
	}

	public int getRelockTimeout() {
		return mRelockTimeout;
	}

	public String getPassword() {
		return mPassword;
	}

	public void setPassword(String password) {
		mPassword = password;
		mPref.edit().putString(PREF_PASSWORD, password).commit();
		this.reloadPreferences();
	}

	public String getGestureSequence() {
		return mGestureSequence;
	}

	public void setGestureSequence(String gesture) {
		Log.d(Setting.TAG,"Saving pass====="+gesture); //LRD
		mGestureSequence = gesture;
		mPref.edit().putString(PREF_GESTURE, gesture).commit();
	}

	@Override
	public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,
			String key) {
		reloadPreferences();
	}

	public void saveApplicationList(String[] applicationList) {
		mApplicationList = applicationList;
		String combined = "";
		for (int i = 0; i < mApplicationList.length; i++) {
			combined = combined + mApplicationList[i] + ";";
		}
		mPref.edit().putString(PREF_APPLICATION_LIST, combined).commit();
	}

	public void saveServiceEnabled(boolean serviceEnabled) {
		mServiceEnabled = serviceEnabled;
		mPref.edit().putBoolean(PREF_SERVICE_ENABLED, mServiceEnabled);
	}

	/** Private Members **/
	private static final String PREF_SERVICE_ENABLED = "service_enabled";
	private static final String PREF_APPLICATION_LIST = "application_list";
	private static final String PREF_AUTO_START = "start_service_after_boot";
	private static final String PREF_PASSWORD = "password";
	private static final String PREF_GESTURE = "gesture";
	private static final String PREF_RELOCK_POLICY = "relock_policy";
	private static final String PREF_RELOCK_TIMEOUT = "relock_timeout";
	private static final String PREF_FIRST_USE = "first_use";
	private static final String PREF_WEEKLY_REPORT = "weekly_report";

	public static final String TAG = "nevin";
	public static final String APP_VERSION = "App Version";
	public static final String LOCKED_APP = "Locked App";
	
	private SharedPreferences mPref;
	private static Setting mInstance;
	private boolean mServiceEnabled, mAutoStart,mWeeklyReport ;
	private String[] mApplicationList;
	private String mPassword;
	private int mRelockTimeout;
	private String mGestureSequence;
	private boolean mFirstUse;
	private Context mContext;
	
	
	private Setting(Context context) {
		mPref = PreferenceManager.getDefaultSharedPreferences(context);
		mPref.registerOnSharedPreferenceChangeListener(this);
		reloadPreferences();
		mContext = context;
	}

	private void reloadPreferences() {
		mServiceEnabled = mPref.getBoolean(PREF_SERVICE_ENABLED, false);
		mApplicationList = mPref.getString(PREF_APPLICATION_LIST, "")
				.split(";");
		mAutoStart = mPref.getBoolean(PREF_AUTO_START, false);
		mPassword = mPref.getString(PREF_PASSWORD, "");						// Default password is empty
		mGestureSequence = mPref.getString(PREF_GESTURE, "DOWN DOWN DOWN");	// Default questure is Down*3
		mFirstUse = mPref.getBoolean(PREF_FIRST_USE, true);
		mWeeklyReport = mPref.getBoolean(PREF_WEEKLY_REPORT, true);
		
		if (mPref.getBoolean(PREF_RELOCK_POLICY, true)) {
			try {
				mRelockTimeout = Integer.parseInt(mPref.getString(
						PREF_RELOCK_TIMEOUT, "-1"));
			} catch (Exception e) {
				mRelockTimeout = -1;
			}
		} else {
			mRelockTimeout = -1;
		}
	}
	 
	public void sendMail(String to ,String subject, String messageBody, String filename) {
		Session session = createSessionObject();
		
		try {
			Message message = createMessage(to, subject,
					messageBody, session, filename);
			new SendMailTask().execute(message);
			Log.d(Setting.TAG, "send to " + to + "\nsubject:" +  subject + "\ntext: \n"
					+ messageBody);
		} catch (AddressException e) {
			e.printStackTrace();
		} catch (MessagingException e) {
			e.printStackTrace();
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
	}

	private class SendMailTask extends AsyncTask<Message, Void, Void> {

		@Override
		protected void onPreExecute() {
			super.onPreExecute();
		}

		@Override
		protected void onPostExecute(Void aVoid) {
			super.onPostExecute(aVoid);
			Log.d(Setting.TAG, "SendMailTask complete");
		}

		@Override
		protected Void doInBackground(Message... messages) {
			try {
				Log.i(Setting.TAG, "SendMailTask doInBackground");
				Transport.send(messages[0]);
			} catch (MessagingException e) {
				e.printStackTrace();
			}
			return null;
		}
	}

	private Message createMessage(String email, String subject,
			String messageBody, Session session, String filename)
			throws MessagingException, UnsupportedEncodingException {
		MimeMessage message = new MimeMessage(session);
		message.setFrom(new InternetAddress(Setting.SERVICE_MAIL_ACCOUNT, "AirLocker Admin"));
		message.addRecipient(Message.RecipientType.TO, new InternetAddress(
				email, email));
		message.setSubject(subject);

		String mSign = mContext.getResources().getString(R.string.mail_footer);
		
		if (filename != null) {
			BodyPart messageBodyPart = new MimeBodyPart();
			messageBodyPart.setText(messageBody+"\n"+mSign);
			Multipart multipart = new MimeMultipart();
			multipart.addBodyPart(messageBodyPart);
			messageBodyPart = new MimeBodyPart();
			DataSource source = new FileDataSource(filename);
			messageBodyPart.setDataHandler(new DataHandler(source));
			messageBodyPart.setFileName(filename);
			multipart.addBodyPart(messageBodyPart);
			message.setContent(multipart);
		}else{
			message.setText(messageBody);
		}

		return message;
	}

	private Session createSessionObject() {
		Properties properties = new Properties();
		properties.put("mail.smtp.auth", "true");
		properties.put("mail.smtp.starttls.enable", "true");
		properties.put("mail.smtp.host", "smtp.gmail.com");
		properties.put("mail.smtp.port", "587");

		return Session.getInstance(properties, new javax.mail.Authenticator() {
			protected PasswordAuthentication getPasswordAuthentication() {
				return new PasswordAuthentication(Setting.SERVICE_MAIL_ACCOUNT, Setting.SERVICE_MAIL_PASSWORD);
			}
		});
	}
	
	public void enableWeeklyReportOnStartup(boolean enable){
		Log.d(Setting.TAG,"enableWeeklyReportOnStartup :" + enable);
		// Set the alarm to start at approximately 2:00 p.m.
		Calendar calendar = Calendar.getInstance();
		calendar.setTimeInMillis(System.currentTimeMillis());
		calendar.set(Calendar.HOUR_OF_DAY, 23);
		int hashDate = mPassword==null?0:(mPassword.length()%7) ;
		calendar.set(Calendar.DAY_OF_WEEK, hashDate );
		
		Log.d(Setting.TAG,"AirLocker weekly report on "+hashDate + "th day of the week ");
		
		Intent pintent = new Intent(mContext, Bcr_BroadcastReceiver.class);
		pintent.setAction(ACTION_WEEKLYREPORT_SEND);
		PendingIntent alarmIntent = PendingIntent.getBroadcast(mContext, 0, pintent, PendingIntent.FLAG_UPDATE_CURRENT);
		AlarmManager alarmMgr = (AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
		
		if (enable){
			// With setInexactRepeating(), you have to use one of the AlarmManager interval constants
			alarmMgr.setInexactRepeating(AlarmManager.RTC_WAKEUP, calendar.getTimeInMillis(),
			        AlarmManager.INTERVAL_DAY*7, alarmIntent);
					//1000 * 60 * 1, alarmIntent);
		}else{
			alarmIntent.cancel();
			alarmMgr.cancel(alarmIntent);
		}
	}
	
	public void sendWeeklyReport(){
		Log.d(Setting.TAG,"sendWeeklyReport");
		// Private member for DB operation
		SQLiteDatabase mDB;
		DaoMaster mDaoMaster;
		DaoSession mDaoSession;
		AppLogDao mAppLogDao;
		DevOpenHelper mDevOpenHelper;

		// Setup DB operation
		mDevOpenHelper= new DaoMaster.DevOpenHelper(mContext,
				"airlocker-db", null);
		mDB = mDevOpenHelper.getWritableDatabase();
		mDaoMaster = new DaoMaster(mDB);
		mDaoSession = mDaoMaster.newSession();
		mAppLogDao = mDaoSession.getAppLogDao();

		Calendar cal = Calendar.getInstance();
		Date dnow = cal.getTime();
		cal.add(Calendar.DATE, -7);
		Date dlastW= cal.getTime();
		QueryBuilder<AppLog> qb = mAppLogDao.queryBuilder().where(AppLogDao.Properties.Time.between(dlastW,dnow));
		ArrayList<AppLog> logs = (ArrayList<AppLog>)qb.list() ;
		
		if (logs.size()>0){
			StringBuilder history = new StringBuilder();
			SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd k:m:s");
			
			String mailPart1 = mContext.getResources().getString(R.string.mail_app_history_1);
			String mailPart2 = mContext.getResources().getString(R.string.mail_app_history_2);
			String mailPart3 = mContext.getResources().getString(R.string.mail_app_history_3);
			String mailPart4 = mContext.getResources().getString(R.string.mail_app_history_4);
			String mailPart5 = mContext.getResources().getString(R.string.mail_app_history_5);
			String mailTitle = mContext.getResources().getString(R.string.mail_app_history_title);
			try {
				
				ApplicationInfo info;
				history.append(mailPart1).append(sdf.format(dlastW)).append(" ~ ").append(sdf.format(dnow)).append("\n");
				for (AppLog log : logs){
					info = mContext.getPackageManager().getApplicationInfo(log.getApp_name(),0);
					
					history.append(mailPart2).append(sdf.format(log.getTime())).append("	");
					history.append(mailPart3).append(info.loadLabel(mContext.getPackageManager())).append("	");
					history.append(mailPart4).append(log.getLatitude()).append("	");
					history.append(mailPart5).append(log.getLongtitude()).append("\n");
				}
			} catch (NameNotFoundException e) {
				e.printStackTrace();
			} 
	
			Account[] accounts = AccountManager.get(mContext).getAccounts();
	
			Setting.getInstance(mContext).sendMail(accounts[0].name, mailTitle,
					history.toString(), null);
		}
		mDaoMaster.getDatabase().close();
		mDaoSession.getDatabase().close();
		mDB.close();
		mDevOpenHelper.close();
		mDaoMaster=null;
		mDaoSession=null;
		mDB=null;
		mDevOpenHelper=null;
	}
	

}
